import os
import logging
import blocksci
import argparse
import ipaddress
from datetime import datetime
from collections import defaultdict
from lib import blockchain_feature_extraction as bs
from lib import tags_apis
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
from cryptography.exceptions import InvalidTag
import binascii

bitab = None

#----------- Pony oracle ---------

def encode(ip):
    octets = [f"{hex(int(o))}".split('x')[1] for o in ip.split('.')]
    v1 = int(octets[1] + octets[0], 16)
    v2 = int(octets[3] + octets[2], 16)
    return v1, v2

def decode(v1, v2):
    MAX = 65535
    if v1 > MAX or v2 > MAX or not v1 or not v2:
        return None
    part1 = f"{hex(v1)}".split('x')[1]
    part2 = f"{hex(v2)}".split('x')[1]
    # We assume that in small numbers, the most significant digit is 0
    if len(part1) == 3:
        part1 = f"0{part1}"
    if len(part2) == 3:
        part2 = f"0{part2}"
    if len(part1) != 4 or len(part2) != 4:
        return None
    o1 = int(part1[2:], 16)
    o2 = int(part1[:2], 16)
    o3 = int(part2[2:], 16)
    o4 = int(part2[:2], 16)
    return f"{o1}.{o2}.{o3}.{o4}"

def extract_ips(addr, txes, max_delta=60*60, ignore_repeated=True):
    max_ins = 3
    max_outs = 2
    sequence = []
    sequences = []
    last_value = None
    not_valid_outs = 0
    # TODO It's not common that the same address appears as output twice in
    # the same transaction, check if it happens
    outputs = {str(o.tx.hash): o.value for t in txes['d_txes']\
            for o in t.outputs if o.address == addr}
    tx1, tx2 = None, None
    ts2 = None
    close_tx = False
    for t in sorted(txes['txes'], key=lambda t: t.index):
        # Incoming tx
        if t in txes['d_txes']:

            # Valid behavior
            if t.inputs.size <= max_ins and t.outputs.size <= max_outs \
                    and 'nulldata' not in t.outputs.address.full_type:
                value = outputs[str(t.hash)]

                # The value is repeated, omit it
                if ignore_repeated and value == last_value:
                    continue

                # A first tx exists, decode
                if tx1:
                    tx2, tx2_value = t, value
                    ts1 = datetime.utcfromtimestamp(tx1.block.timestamp)
                    ts2 = datetime.utcfromtimestamp(tx2.block.timestamp)
                    delta = (ts2 - ts1).total_seconds()
                    # Delta between pair of txes too large
                    if max_delta and delta > max_delta:
                        # If the prev tx was close to the pair, check if decode
                        if close_tx:
                            ip = decode(last_tx2_val, tx1_value)
                            # If the last two values form a valid IP, drop tx1
                            if ip and not is_private(ip):
                                # Recover (uncut) the sequence if it was
                                # dropped due to found a private IP
                                if last_pair_private:
                                    sequence = sequences.pop()
                                    s = {
                                            'tx1': last_tx1.hash,
                                            'tx2': last_tx2.hash,
                                            'ts1': last_ts1,
                                            'ts2': last_ts2,
                                            'ip': None
                                        }
                                    sequence.append(s)
                                    last_pair_private = False
                                s = sequence[-1]
                                s['tx1'] = s['tx2']
                                s['ts1'] = s['ts2']
                                s['tx2'] = tx1.hash
                                s['ts2'] = ts1
                                s['ip'] = ip
                            else:
                                sequences.append(sequence)
                                sequence = []
                        # Just cut the sequence
                        else:
                            sequences.append(sequence)
                            sequence = []
                        #  At the end always replace tx1 with t
                        tx1, tx1_value = t, value
                        close_tx = False
                    # Two consecutive txes with small delta
                    else:
                        ip = decode(tx1_value, tx2_value)
                        # Valid IP
                        if ip and not is_private(ip):
                            s = {
                                    'tx1': tx1.hash,
                                    'tx2': tx2.hash,
                                    'ts1': ts1,
                                    'ts2': ts2,
                                    'ip': ip
                                }
                            sequence.append(s)
                            last_pair_private = False
                        else: # cut the sequence
                            sequences.append(sequence)
                            sequence = []
                            last_pair_private = True
                        last_tx1, last_tx2 = tx1, tx2 # Save last valid pair
                        last_ts1, last_ts2 = ts1, ts2
                        last_tx1_val, last_tx2_val = tx1_value, tx2_value
                        tx1 = None

                # This is the first tx after a pair, or the very first
                else:
                    if ts2 and max_delta:
                        ts = datetime.utcfromtimestamp(t.block.timestamp)
                        delta = (ts-ts2).total_seconds()
                        # when 3 txes are received in a short delta time,
                        # this flag serves to decide which txes form a valid IP
                        if delta < max_delta:
                            close_tx = True

                    # Assign this as the first tx of the pair
                    tx1, tx1_value = t, value

                last_value = value

            else: # Bad behavior incoming_tx, cut the sequence
                sequences.append(sequence)
                sequence = []
                tx1, ts2, close_tx = None, None, False

        # Outgoing tx
        else:
            # Bad behavior outgoing_tx
            if t.outputs.size != 1 or \
                    set(t.inputs.address.to_list()) - set([addr]):
                not_valid_outs += 1
            # cut the sequence
            sequences.append(sequence)
            sequence = []
            tx1, ts2, close_tx = None, None, False

    # Save the last sequence
    if sequence:
        sequences.append(sequence)

    return sequences, not_valid_outs

def oracle_pony(addr, txes):
    """ Return a list with all the IPs decoded for a given address, or empty if
    is not possible to decode any IP
    :param addr: Bitcoin address
    :param txes: Transactions of the BTC address
    """
    sequences, not_valid_outs = extract_ips(addr, txes)
    ips = [ip for sequence in sequences for ip in sequence]
    perc = (2*len(ips))/len(txes['d_txes']) if txes['d_txes'] else -1.0
    return {'perc': perc, 'iocs': ips}

def is_private(ip):
    '''
    Filter IPv4 addresses according to IANA IPv4 special registry. See
    https://www.iana.org/assignments/iana-ipv4-special-registry/
    iana-ipv4-special-registry.xhtml
    '''
    return ipaddress.ip_address(ip).is_private


#----------- Cerber oracle ---------

def oracle_cerber(addr, txes):
    '''
    Return all withdrawal txes signaling gateway domains of cerber
    :param addr: BlockSci Bitcoin address
    :param txes: Withdrawal txes of address
    '''
    sig = signaling_txes(addr, txes)
    perc = len(sig) / len(txes) if txes else -1.0
    return {'perc': perc, 'iocs': sig}

def signaling_txes(addr, in_txes):
    sigtxes = []
    # Analyze withdrawal (input) txes of addr
    for tx in in_txes:
        valid = valid_tx(addr, tx)
        if not valid:
            continue
        sigtxes.append(valid)
    return sigtxes

def valid_tx(addr, tx):
    # there should be only 1 input and 1 output in this TX
    if tx.input_count == tx.output_count == 1:
        # deposit address
        o = tx.outputs[0].address
        # it should have only 1 deposit TX and 1 withdrawal TX
        if o.input_txes.size == o.output_txes.size == 1:
            # tx for returning the BTC to addr
            tx2 = o.input_txes.to_list()[0]
            # returning TX should have only 1 input and 1 output
            if tx2.input_count == tx2.output_count == 1:
                # returning TX is a deposit to addr
                if tx2.outputs[0].address == addr:
                    # TX output value equals Tx2.fee + TX2.output value
                    if tx.output_value == tx2.fee + tx2.output_value:
                        return {
                                    'domain': bs.addr_to_string(o)[:6],
                                    'tx1': tx.hash, 'tx2': tx2.hash,
                                    'ts1': tx.block_time, 'ts2': tx2.block_time
                               }
    return {}


#----------- BitcoinAbuse oracle ---------

def oracle_bitab(addr, update=False):
    global bitab
    if bitab is None:
        bitab = tags_apis.all_reports(update)
    addr_str = bs.addr_to_string(addr)
    info = bitab[bitab.address==addr_str].to_dict('records')
    perc = 1.0 if info else 0.0
    return {'perc': perc, 'iocs': info}


#----------- Glupteba oracle ---------

# https://cryptography.io/en/latest/hazmat/primitives/aead/#cryptography.hazmat.primitives.ciphers.aead.AESGCM
def decrypt(data, key):
    """
    Decrypt a data hidden in a OP_RETURN script using AESGCM with a key of 256
    bits. The script is hex encoded, so we take the first 12 bytes (each char
    is half a byte) as the IV, the last 16 as the GCM tag, and the rest as the
    encrypted domain.
    """
    key = binascii.unhexlify(key)
    aesgcm = AESGCM(key)
    # Each byte is two characters lenght
    iv = binascii.unhexlify(data[:12*2])
    tag = binascii.unhexlify(data[-16*2:])
    data = binascii.unhexlify(data[12*2:-16*2])
    try:
        return aesgcm.decrypt(iv, data+tag, None)
    except InvalidTag as e:
        return None

def search_domains(addr, txes, keys):
    domains = []
    for t in txes:
        for o in t.outputs.to_list():
            # We take the OP_RETURN script in hex format, if any
            data = o.address.data.hex() if hasattr(o.address, 'data') else None
            # We are searching scripts of lenght at least:
            # 12 bytes of nonce + 16 bytes of tag + N bytes of data
            if data and len(data) >= (12+16)*2:
                found = False
                for k in keys:
                    plain_text = decrypt(data, k)
                    if plain_text:
                        found = True
                        ts = datetime.utcfromtimestamp(o.block.timestamp)
                        d = {
                                'tx': t.hash,
                                'ts': ts,
                                'oidx': o.index,
                                'key': k,
                                'data': data,
                                'domain': plain_text}
                        domains.append(d)
                if not found:
                    msg = f"{addr} withdraws to OP_RETURN script with "
                    msg += f"undecryptable data. TX {t.hash},{o.index} "
                    msg += f"(len={len(data)}): {data}"
                    logging.warning(msg)
    return domains

def oracle_glupteba(addr, txes, keys):
    domains = search_domains(addr, txes, keys)
    perc = 1.0 if domains else 0.0
    return {'perc': perc, 'iocs': domains}
