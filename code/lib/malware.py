""" Module for handling malware oracles """

import logging
import ipaddress
from datetime import datetime
from itertools import cycle
import binascii
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
from cryptography.exceptions import InvalidTag
from lib import blockchain_feature_extraction as bs
#from lib import tags_apis
import blocksci

#bitab = None

#----------- Pony oracle ---------

def encode(ip):
    """
    Function to encode an IP in two decimal values
    """
    octets = [f"{hex(int(o))}".split('x')[1] for o in ip.split('.')]
    v1 = int(octets[1] + octets[0], 16)
    v2 = int(octets[3] + octets[2], 16)
    return v1, v2

def decode(v1, v2):
    """
    Function to decode an IP from two decimal values
    """
    MAX = 65535
    if v1 > MAX or v2 > MAX or not v1 or not v2:
        return None
    part1 = f"{hex(v1)}".split('x')[1]
    part2 = f"{hex(v2)}".split('x')[1]
    # We assume that in small numbers, the most significant digit is 0
    if len(part1) == 3:
        part1 = f"0{part1}"
    if len(part2) == 3:
        part2 = f"0{part2}"
    if len(part1) != 4 or len(part2) != 4:
        return None
    o1 = int(part1[2:], 16)
    o2 = int(part1[:2], 16)
    o3 = int(part2[2:], 16)
    o4 = int(part2[:2], 16)
    return f"{o1}.{o2}.{o3}.{o4}"

def extract_ips(addr, txes, max_delta=60*60, ignore_repeated=True):
    """
    Function to find two consecutive txes that decode an IP.
    :param addr: Bitcoin address
    :param txes: Bitcoin txes of an address (dict)
    :param max_delta: Maximum number of seconds between the consecutive txes
    :param ignore_repeated: Ignore the second tx of two with the same amount
    """
    max_ins = 3
    max_outs = 2
    sequence = []
    sequences = []
    last_value = None
    not_valid_outs = 0
    # TODO It's not common that the same address appears as output twice in
    # the same transaction, check if it happens
    outputs = {str(o.tx.hash): o.value for t in txes['d_txes']\
            for o in t.outputs if o.address == addr}
    tx1, tx2 = None, None
    ts2 = None
    close_tx = False
    for t in sorted(txes['txes'], key=lambda t: t.index):
        # Incoming tx
        if t in txes['d_txes']:

            # Valid behavior
            if t.inputs.size <= max_ins and t.outputs.size <= max_outs \
                    and 'nulldata' not in t.outputs.address.full_type:
                value = outputs[str(t.hash)]

                # The value is repeated, omit it
                if ignore_repeated and value == last_value:
                    continue

                # A first tx exists, decode
                if tx1:
                    tx2, tx2_value = t, value
                    ts1 = datetime.utcfromtimestamp(tx1.block.timestamp)
                    ts2 = datetime.utcfromtimestamp(tx2.block.timestamp)
                    delta = (ts2 - ts1).total_seconds()
                    # Delta between pair of txes too large
                    if max_delta and delta > max_delta:
                        # If the prev tx was close to the pair, check if decode
                        if close_tx:
                            ip = decode(last_tx2_val, tx1_value)
                            # If the last two values form a valid IP, drop tx1
                            if ip and not is_private(ip):
                                # Recover (uncut) the sequence if it was
                                # dropped due to found a private IP
                                if last_pair_private:
                                    sequence = sequences.pop()
                                    s = {
                                        'tx1': last_tx1.hash,
                                        'tx2': last_tx2.hash,
                                        'ts1': last_ts1,
                                        'ts2': last_ts2,
                                        'ip': None
                                    }
                                    sequence.append(s)
                                    last_pair_private = False
                                s = sequence[-1]
                                s['tx1'] = s['tx2']
                                s['ts1'] = s['ts2']
                                s['tx2'] = tx1.hash
                                s['ts2'] = ts1
                                s['ip'] = ip
                            else:
                                sequences.append(sequence)
                                sequence = []
                        # Just cut the sequence
                        else:
                            sequences.append(sequence)
                            sequence = []
                        #  At the end always replace tx1 with t
                        tx1, tx1_value = t, value
                        close_tx = False
                    # Two consecutive txes with small delta
                    else:
                        ip = decode(tx1_value, tx2_value)
                        # Valid IP
                        if ip and not is_private(ip):
                            s = {
                                'tx1': tx1.hash,
                                'tx2': tx2.hash,
                                'ts1': ts1,
                                'ts2': ts2,
                                'ip': ip
                            }
                            sequence.append(s)
                            last_pair_private = False
                        else: # cut the sequence
                            sequences.append(sequence)
                            sequence = []
                            last_pair_private = True
                        last_tx1, last_tx2 = tx1, tx2 # Save last valid pair
                        last_ts1, last_ts2 = ts1, ts2
                        # last_tx1_val, last_tx2_val = tx1_value, tx2_value
                        _, last_tx2_val = tx1_value, tx2_value
                        tx1 = None

                # This is the first tx after a pair, or the very first
                else:
                    if ts2 and max_delta:
                        ts = datetime.utcfromtimestamp(t.block.timestamp)
                        delta = (ts-ts2).total_seconds()
                        # when 3 txes are received in a short delta time,
                        # this flag serves to decide which txes form a valid IP
                        if delta < max_delta:
                            close_tx = True

                    # Assign this as the first tx of the pair
                    tx1, tx1_value = t, value

                last_value = value

            else: # Bad behavior incoming_tx, cut the sequence
                sequences.append(sequence)
                sequence = []
                tx1, ts2, close_tx = None, None, False

        # Outgoing tx
        else:
            # Bad behavior outgoing_tx
            if t.outputs.size != 1 or \
                    set(t.inputs.address.to_list()) - set([addr]):
                not_valid_outs += 1
            # cut the sequence
            sequences.append(sequence)
            sequence = []
            tx1, ts2, close_tx = None, None, False

    # Save the last sequence
    if sequence:
        sequences.append(sequence)

    return sequences, not_valid_outs

def oracle_pony(addr, txes):
    """
    Return a list with all the IPs decoded for a given address, or empty if it
    is not possible to decode any IP
    :param addr: Bitcoin address
    :param txes: Transactions of the BTC address
    """
    sequences, not_valid_outs = extract_ips(addr, txes)
    ips = [ip for sequence in sequences for ip in sequence]
    perc = (2*len(ips))/len(txes['d_txes']) if txes['d_txes'] else -1.0
    if not_valid_outs:
        logging.warning("Not valid outs found: %s", not_valid_outs)
    return {'perc': perc, 'iocs': ips}

def is_private(ip):
    """
    Filter IPv4 addresses according to IANA IPv4 special registry. See
    https://www.iana.org/assignments/iana-ipv4-special-registry/
    iana-ipv4-special-registry.xhtml
    """
    return ipaddress.ip_address(ip).is_private


#----------- Cerber oracle ---------

def oracle_cerber(addr, txes):
    """
    Return all withdrawal txes signaling gateway domains of cerber
    :param addr: BlockSci Bitcoin address
    :param txes: Withdrawal txes of address
    """
    sig = are_txes_cerber_signaling(addr, txes)
    perc = len(sig) / len(txes) if txes else -1.0
    return {'perc': perc, 'iocs': sig}

def are_txes_cerber_signaling(addr, in_txes):
    """
    Check if a set of withdrawal txes match with cerber's signaling pattern.
    """
    sigtxes = []
    # Analyze withdrawal (input) txes of addr
    for tx in in_txes:
        valid = is_tx_cerber_signaling(addr, tx)
        if not valid:
            continue
        sigtxes.append(valid)
    return sigtxes

def is_tx_cerber_signaling(addr, tx):
    """
    Check if a withdrawal tx matchs with cerber's signaling pattern.
    """
    # there should be only 1 input and 1 output in this TX
    if tx.input_count == tx.output_count == 1:
        # deposit address
        o = tx.outputs[0].address
        # it should have only 1 deposit TX and 1 withdrawal TX
        if o.input_txes.size == o.output_txes.size == 1:
            # tx for returning the BTC to addr
            tx2 = o.input_txes.to_list()[0]
            # returning TX should have only 1 input and 1 output
            if tx2.input_count == tx2.output_count == 1:
                # returning TX is a deposit to addr
                if tx2.outputs[0].address == addr:
                    # TX output value equals Tx2.fee + TX2.output value
                    if tx.output_value == tx2.fee + tx2.output_value:
                        return {
                            'domain': bs.addr_to_string(o)[:6],
                            'tx1': tx.hash, 'tx2': tx2.hash,
                            'ts1': tx.block_time, 'ts2': tx2.block_time
                        }
    return {}


##----------- BitcoinAbuse oracle ---------
#
#def oracle_bitab(addr, update=False):
#    global bitab
#    if bitab is None:
#        bitab = tags_apis.all_reports(update)
#    addr_str = bs.addr_to_string(addr)
#    info = bitab[bitab.address==addr_str].to_dict('records')
#    perc = 1.0 if info else 0.0
#    return {'perc': perc, 'iocs': info}


#----------- Glupteba oracle ---------

def oracle_glupteba(txes, keys):
    """
    Return all withdrawal txes signaling C&C domains of glupteba
    :param txes: Set of withdrawal txes
    :param keys: Set of AES keys to decrypt the OPRETURN value
    """
    domains = are_txes_glupteba_signaling(txes, keys)
    perc = 1.0 if domains else 0.0
    return {'perc': perc, 'iocs': domains}

def are_txes_glupteba_signaling(txes, keys):
    """
    Determine if the withdrawal txes are signaling C&C domains of glupteba
    """
    domains = []
    for t in txes:
        d = is_tx_glupteba_signaling(t, keys)
        if d:
            domains.append(d)
    return domains

def is_tx_glupteba_signaling(t, keys):
    """
    Determine if a withdrawal tx is signaling C&C domains of glupteba
    """
    d = {}
    for o in t.outputs.to_list():
        # We take the OP_RETURN script in hex format, if any
        data = o.address.data.hex() if hasattr(o.address, 'data') else None
        # We are searching scripts of lenght at least:
        # 12 bytes of nonce + 16 bytes of tag + N bytes of data
        # found = False
        if data:
            aes = len(data) >= (12+16)*2
            plain_text = None
            for k in keys:
                if aes and len(k)%2 == 0:
                    plain_text = decrypt_aes(data, k)
                if not plain_text:
                    plain_text = decrypt_xor(data, k)
                if plain_text:
                    # found = True
                    ts = datetime.utcfromtimestamp(o.block.timestamp)
                    d = {
                        'tx': t.hash,
                        'ts': ts,
                        'oidx': o.index,
                        'key': k,
                        'data': data,
                        'domain': plain_text
                    }
                    break
#            if not found and not str(o.address.data).startswith('omni'):
#                msg = (f"TX {t.hash},{o.index} with undecryptable data "
#                       f"(len={len(data)}): {data}")
#                logging.warning(msg)
    return d

# https://cryptography.io/en/latest/hazmat/primitives/aead/#cryptography.hazmat.primitives.ciphers.aead.AESGCM
def decrypt_aes(data, key):
    """
    Decrypt data hidden in a OP_RETURN script using AESGCM with a key of 256
    bits. The script is hex encoded, so we take the first 12 bytes (each char
    is half a byte) as the IV, the last 16 as the GCM tag, and the rest as the
    encrypted domain.
    """
    key = binascii.unhexlify(key)
    aesgcm = AESGCM(key)
    # Each byte is two characters lenght
    iv = binascii.unhexlify(data[:12*2])
    tag = binascii.unhexlify(data[-16*2:])
    data = binascii.unhexlify(data[12*2:-16*2])
    try:
        return aesgcm.decrypt(iv, data+tag, None)
    except InvalidTag:
        return None

def decrypt_xor(data, key):
    """
    Decrypt data hidden in an OP_RETURN script using a simple XOR decryption.
    This function support the data as bytes or as an hex string.
    Return the decrypted text only if it is alphanumeric (due to any string
    could be decrypted using aby key when using XOR).
    """
    try:
        if isinstance(data, bytes):
            data = data.decode()
        else:
            data = binascii.unhexlify(data).decode()
    except UnicodeDecodeError:
        return None
    text = ''.join(chr(ord(c)^ord(k)) for c, k in zip(data, cycle(key)))
    return text if all([t.isalnum() for t in text.split('.')]) else None

#----------- Deadbolt oracle ---------

def oracle_deadbolt(txes):
    """
    Determine the percentage of transactions that match the pattern of a
    deadbolt key sender, and return it along with some more information found
    within the transactions analyzed.
    """
    ks = are_txes_deadbolt_key_sender(txes)
    perc = len(ks) / len(txes) if txes else 0.0
    return {'perc': perc, 'iocs': ks}

def are_txes_deadbolt_key_sender(txes):
    """
    Analyze a set of transactions to determine how many of them match the
    pattern of a deadbolt key sender.
    """
    release_key_txes = []
    for t in txes:
        d = is_tx_deadbolt_key_sender(t)
        if d:
            release_key_txes.append(d)
    return release_key_txes

def is_tx_deadbolt_key_sender(t):
    """
    Analyze a single transaction to search for an OP_RETURN address, an address
    receiving 5460 satoshis (ransomware address), and a change address that is
    the same than the sender.
    """
    d = {}
    ransom_addr = None
    op_ret = None
    change_addr = None
    senders = set(t.inputs.address.to_list())
    if len(senders) == 1 and t.output_count == 3:
#    if t.input_count == 1 and t.output_count == 3:
        sender = senders.pop()
#        sender = t.inputs.address.to_list()[0]
        for o in t.outputs.to_list():
            # Check if this address receives 5460 satoshis (ransomware address)
            if o.value == 5460:
                ransom_addr = bs.addr_to_string(o.address)
            # Check if this output is the same than the sender (change address)
            if o.address == sender:
                change_addr = bs.addr_to_string(o.address)
            # Check if this is an OP_RETURN address with a 32 length string
            if o.address_type == blocksci.address_type(6) and \
                len(o.address.data.hex()) == 32:
                # Omit txes of the OMNI protocol that match this same pattern
                # TODO check this change!!
                # if not 'omni' in str(o.address.data):
                if 'omni' not in str(o.address.data):
                    op_ret = bs.addr_to_string(o.address)
        if ransom_addr and op_ret and change_addr:
            d = {
                'sender': sender,
                'ransom_addr': ransom_addr,
                'op_ret' : op_ret
            }
    return d
